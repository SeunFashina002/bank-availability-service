Bank Availability Service: Junior Engineer Take-Home Assessment
Hi there! This take-home assessment is designed to help us understand your approach to problem-solving, coding, and basic system design. We're excited to see what you build!
The goal is to create a small service that calculates and reports the availability of banks based on simulated transaction data.
ğŸ¯
Project Goal
Build a Bank Availability Service that can:
1. Processtransactionstatusdatafordifferentbanks.
2. Calculateanavailabilitypercentageforeachbankoverarecenttimewindow. 3. ExposethisinformationviaasimpleAPI.
ğŸ¤”
Core Problem to Solve
Imagine we process many transactions involving various banks. Sometimes, a beneficiary bank might be experiencing technical difficulties, leading to failed or delayed transactions. We need a quick way to:
â— Estimate how "available" or "healthy" a bank seems based on recent transaction outcomes.
â— Use this information to potentially make smarter routing decisions or inform users about issues.
ğŸ› 
Your Task: Build the Core Service
For this assessment, you'll implement a simplified version of this service.
Core Functionality Requirements:
â— The service MUST calculate bank availability based on transaction status codes.
â— Availability MUST be expressed as a percentage.
â— The primary calculation MUST use transactions from the last 1 hour.
â— The service MUST expose an API endpoint to get the availability of a specific
bank.
â— The API response MUST include a "confidence level" for the availability score.
â— Calculated data SHOULD be stored (e.g., in memory for this exercise is fine).
ğŸ”¢
Bank Availability Calculation Logic:
 1. InputData:
â—‹ Your service will need to process transaction outcomes. For this assessment, you can simulate receiving this data. For example, you could:
â– 
â–  â—‹ Each
â–  â–  â– 
Create a function that generates a list of sample transaction records.
Hardcode a list of sample transactions.
relevant transaction record should have at least: (String, e.g., "BANK_A", "BANK_B")
(String)
(ISO 8601 String or datetime object, e.g.,
 bank_code
 status_code
 timestamp
"2025-05-26T10:00:00Z")
2. StatusCodesforCalculation:
â—‹ "00": Successful transaction. Counts towards "available" transactions.
â—‹ "91": Beneficiary bank unavailable. Counts towards "unavailable"
transactions. (Other status codes can be ignored for the main task).
3. AvailabilityPercentageFormula:
For a given bank_code and the last 1-hour time window:
â—‹ = Count of transactions with   .
â—‹ = Count of transactions with   . â—‹=+. â—‹ If     =null.
â—‹ Else,   =(   /
) * 100.0.
4. ConfidenceLevel:
The confidence level is derived from the total_relevant_transactions for the bank in the time window:
 successful_transactions
status_code="00"
 unavailable_transactions
status_code="91"
   total_relevant_transactions
successful_transactions
unavailable_transactions
total_relevant_transactions == 0
, then
availability_percentage
availability_percentage
successful_transactions
 total_relevant_transactions
 â—‹ If
â—‹ Else if
â—‹ Else if
â—‹ Else (
5. DataRefresh/ProcessingTrigger:
: "Insufficient Data" : "Low"
: "Medium" ): "High"
total_relevant_transactions == 0
 total_relevant_transactions <= 5
 total_relevant_transactions <= 20
 total_relevant_transactions > 20
â—‹ For this assessment, you can decide how calculations are triggered. It could be:
â–  When the API is called (calculate on-demand).

 â–  A simple loop in your service that recalculates every X seconds/minutes (simulating periodic updates).
â—‹ Focus on the calculation logic; complex scheduling isn't required.
ğŸ”Œ
API Endpoint to Implement:
â— Endpoint: GET /banks/{bank_code}/availability
â— Description: Retrieves the latest calculated availability for a specific bank.
â— Path Parameter:
â—‹ bank_code (String, required): The identifier of the bank.
â— Success Response (200 OK):
â— JSON
Unset
â—
   {
     "bank_code": "BANK_A",
     "availability_percentage": 95.24, // or null if "Insufficient
   Data"
     "confidence_level": "High", // "Medium", "Low", or "Insufficient
   Data"
     "time_window": "1h", // The time window used for this calculation
     "last_calculated_at": "2025-05-26T10:30:00Z" // Timestamp of when
   this data was calculated
   }
â—
â—
â— Error Responses:
â—‹ 404 Not Found: If the bank_code is not known or has no data.
â—‹ Consider other relevant HTTP status codes for errors if applicable.
ğŸ’¾
Data Storage:
â— Your service needs to store the calculated availability data. For this assessment, in-memory storage is perfectly acceptable (e.g., using dictionaries/maps in your chosen language).
        
 â— You should store at least: â—‹
 bank_code
 â—‹ â—‹ â—‹ â—‹ â—‹
ğŸ’»
Technical Guidelines
â— Language/Framework: You are free to use any programming language and web framework you are comfortable with (e.g., Python with Flask/FastAPI, Node.js with Express, Go, Java with Spring Boot, etc.). Please state your choice in your
availability_percentage
 confidence_level
 (useful for deriving confidence) (e.g.,   )
timestamp
total_transactions_in_window
 status_counts
{"00": count, "91": count}
 last_calculated_at
 submission.
â— Code Clarity: Write clean, readable, and well-structured code. Add comments
where appropriate to explain your logic.
â— Simplicity: We value simple and effective solutions. Avoid over-engineering.
âœ…
Testing Your Solution
Please include tests for your service. We recommend focusing on:
1. UnitTests:
â—‹ Test the availability percentage calculation logic with various inputs (e.g.,
all successful, all failed, mixed statuses, zero transactions).
â—‹ Test the confidence level derivation logic.
2. (OptionalbutRecommended)APIInteractionTest:
â—‹ A simple test to verify that your API endpoint returns the expected
structure and data for a known scenario.
ğŸ“¬
Submission Please provide:
1. Yoursourcecode,includinganytestsyou'vewritten. 2. AbriefREADME.mdfileexplaining:
â—‹ Your choice of language/framework.
â—‹ How to build/run your service.
â—‹ How to run your tests.
   
â—‹ Any assumptions you made or design choices you'd like to highlight.
â­
What We're Looking For
â— Correctness: Does the service accurately implement the calculation logic and API as specified?
â— Code Quality: Is the code clean, well-organized, maintainable, and easy to understand?
â— Problem Solving: Does your solution effectively address the core requirements?
â— Testing: Are there sensible tests that cover the core logic?
â— Understanding: Does your submission demonstrate a good understanding of
the task?
âœ¨
Bonus Challenges (Optional)
If you have extra time and want to showcase more of your skills, consider implementing one or more of these:
1. MultipleTimeWindows:
â—‹ Extend the service to calculate availability for different time windows (e.g.,
"1h", "6h", "24h").
â—‹ Allow the API client to request a specific time window via a query
parameter (e.g., GET /banks/{bank_code}/availability?window=6h). 2. ExpandedStatusCodes:
â—‹ Modify the calculation to include:
â–  "01" (Successful debit, pending credit) - Counts towards "available".
â–  "97" (Beneficiary bank timed out) - Counts towards "unavailable".
3. ListAllBanks:
â—‹ Implement a new endpoint GET /banks/availability that returns the availability
data for all monitored banks for a specified (or default) time window. 4. BasicPersistence:
â—‹ Instead of purely in-memory storage, save the calculated availability data to a file (e.g., JSON, CSV) or a simple embedded database (e.g., SQLite).
â—‹ Load this data when the service starts.